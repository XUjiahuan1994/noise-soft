using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.IO.Ports;
using System.Threading;

namespace ps5000example
{
    public class Coronameasure:Device
    {
        //定义一个链表用于存储各个仪器的状态，状态有三种：ON表示正常，OFF表示未连接，ERR表示异常
        public String[] state = new String[11];
        public int[] recDataInt = new int[11];
        public String[] recDataStr = new String[11];
        //用于存储各个仪器的空间电荷密度值
        public double[] recDataDouble = new double[11];
        //串口
        public SerialPort serialPort;
        //存储1-11号设备的访问命令
        public List<byte[]> cmdList;

        /*
         * CRC16/MODBUS 多项式：8005 数据反转：LSB FIRST
         * 初始值：FFFF 异或值：0000
         */

        public Coronameasure()
        {
            serialPort = new SerialPort();
            interval = 2;
            cmdList = new List<byte[]>();

            cmdList.Add(new byte[] { 0x01, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x0B });
            cmdList.Add(new byte[] { 0x02, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x38 });
            cmdList.Add(new byte[] { 0x03, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC5, 0xE9 });
            cmdList.Add(new byte[] { 0x04, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x5E });
            cmdList.Add(new byte[] { 0x05, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC5, 0x8F });
            cmdList.Add(new byte[] { 0x06, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC5, 0xBC });
            cmdList.Add(new byte[] { 0x07, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x6D });
            cmdList.Add(new byte[] { 0x08, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0x92 });
            cmdList.Add(new byte[] { 0x09, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC5, 0x43 });
            cmdList.Add(new byte[] { 0x0A, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC5, 0x70 });
            cmdList.Add(new byte[] { 0x0B, 0x03, 0x00, 0x00, 0x00, 0x02, 0xC4, 0xA1 });
        }

        /*
         * 实现基本的串口发送命令功能
         */

        public override void sendCmd(byte[] cmd)
        {
            if (!serialPort.IsOpen)
                serialPort.Open();
            serialPort.Write(cmd, 0, cmd.Length);
        }

        /*
        * 实现基本的串口发送命令功能
        */

        public override byte[] readData()
        {
            if (!serialPort.IsOpen)
                serialPort.Open();
            int n = serialPort.ReadBufferSize;
            byte[] buffer = new byte[n + 1];
            serialPort.Read(buffer, 0, n);
            return buffer;
        }

        /*
         * 定义轮询读取数据的方法
         */

        public override void readDataPolling()
        {
            for (int i = 0; i < 11; i++)
            {
                if (!serialPort.IsOpen)
                    serialPort.Open();
                serialPort.Write(cmdList[i], 0, cmdList[i].Length);

                Thread.Sleep(100);
                int n = serialPort.BytesToRead;

                if (n < 1)
                {
                    state[i] = "ON";
                    recDataStr[i] = "ON";
                    recDataDouble[i] = 0;
                }
                else if (n >= 9)
                {

                    byte[] readResult = new byte[n];
                    serialPort.Read(readResult, 0, n);

                    //进行CRC冗余校验和数据解析

                    UInt32 crc = CRC16(readResult, 0, 6);

                    if (readResult[7] == (byte)(crc >> 8) && readResult[8] == (byte)(crc & 0xFF))
                    {
                        state[i] = "ON";
                        byte[] result = new byte[4];
                        result[0] = 0x00;
                        result[1] = readResult[4];
                        result[2] = readResult[5];
                        result[3] = readResult[6];

                        if (BitConverter.IsLittleEndian)
                            Array.Reverse(result);
                        int k = BitConverter.ToInt32(result, 0);

                        recDataStr[i] = Convert.ToString(k);
                        recDataDouble[i] = k;
                    }/*else //若校验错误，则状态标记为“ERR”
                    {
                        state[i] = "ERR";
                        recDataStr[i] = "ERR";
                        recDataDouble[i] = 0;
                    }
                    **/

                    //原版本
                    /*
                    if (readResult.Length >= 9 && readResult[0] == i + 1 && readResult[1] == 131 && readResult[2] == 4)
                    {

                        state[i]= "ON";
                        byte[] result = new byte[4];
                        result[0] = 0x00;
                        result[1] = readResult[4];
                        result[2] = readResult[5];
                        result[3] = readResult[6];                                       

                        if (BitConverter.IsLittleEndian)
                            Array.Reverse(result);
                        int k = BitConverter.ToInt32(result, 0);

                        recDataStr[i] = Convert.ToString(k);
                        recDataDouble[i] = k;
                
                    }else if (readResult[0] != i + 1 || readResult[1] != 131 || readResult[2] != 4)
                    {
                        state[i] = "ERR";
                        recDataStr[i] = "ERR";
                        recDataDouble[i] = 0;
                    }
                    * */
                }
            }
        }

        /*
        * 定义实现仪器归零的方法
         * 要对三个档位全部进行归零
        */

        public override void resetZero()
        {
            byte[] resetZeroCmd = new byte[] { 0x8A, 0x05, 0x00, 0x00, 0x00, 0x04, 0xD2, 0xB2 }; //归零命令
            byte[] switchRangeCmd = new byte[] { 0x8A, 0x05, 0x00, 0x00, 0x00, 0x03, 0x93, 0x70 }; //切换档位命令
            //第一档归零
            sendCmd(resetZeroCmd);
            Thread.Sleep(33000);
            //第二档归零
            sendCmd(resetZeroCmd);
            Thread.Sleep(200);
            sendCmd(switchRangeCmd);
            Thread.Sleep(32800);
            //第三档归零
            sendCmd(resetZeroCmd);
            Thread.Sleep(500);
            sendCmd(switchRangeCmd);
            Thread.Sleep(33000);

        }

        /*
        * 定义重启仪器的方法
        */

        public override void restart()
        {
            byte[] restartCmd = new byte[] { 0x8A, 0x5A, 0x12, 0x34, 0x56, 0x78, 0x3C, 0x48 };  //重启命令
            sendCmd(restartCmd);
            Thread.Sleep(500);
        }

        /*
        * 实现数据存储功能
        */

        public override void storeData()
        {

        }

        public static UInt32 CRC16(Byte[] buffer, int Start, int End)
        {
            //crc高位表
            byte[] _auchCRCHi = new byte[]
            {0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
             0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,
             0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
             0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,
             0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,
             0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,
             0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
             0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,
             0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
             0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
             0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,
             0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
             0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
             0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,
             0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,
             0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,
             0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,
             0x40};

            //crc低位表
            byte[] _auchCRCLo = new byte[]
            {0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4,
             0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09,
             0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD,
             0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3,
             0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7,
             0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A,
             0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE,
             0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26,
             0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2,
             0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F,
             0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB,
             0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5,
             0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91,
             0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C,
             0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88,
             0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C,
             0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80,
             0x40};

            byte crcHi = 0xff; // 高位初始化

            byte crcLo = 0xff; // 低位初始化

            for (int i = Start; i <= End; i++)
            {
                int crcIndex = crcHi ^ buffer[i]; // 查找crc表值

                crcHi = (byte)(crcLo ^ _auchCRCHi[crcIndex]);
                crcLo = _auchCRCLo[crcIndex];
            }
            return (UInt32)(crcHi << 8 | crcLo);
        }

        //例如将0000E7E6转换为59366
        public static UInt32 convertByte(byte[] buf)
        {
            if (BitConverter.IsLittleEndian)
                Array.Reverse(buf);
            UInt32 value = BitConverter.ToUInt32(buf, 0);
            return value;
        }

    }
}
